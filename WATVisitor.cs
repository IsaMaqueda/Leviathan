/*
    Levithan Compiler -  WebAssembly text file (WAT) code generator.

    Camila Rovirosa A01024192
    Eduardo Badillo A01020716
    Isabel Maqueda  A01652906

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;
using System.Collections;

namespace Leviathan {

    class WATVisitor {

        // controller variables
        public int inLoop = 0;
        string idFather = "";


        //variable pila para el while y do while
        Stack pila = new Stack();

        //

        public FunctionTable fTable{
            get; 
            private set;
        }
        public HashSet<string> gVar;
        
        public WATVisitor(FunctionTable functionTable, HashSet<string> globalVariables){
            this.fTable = functionTable;
            this.gVar = globalVariables;
        }

        // global string buffer
        StringBuilder sb = new StringBuilder();
        
        // convert str to utf-32
        public IList<int> AsCodePoints(string str){
            var result = new List<int>(str.Length);
            for(int i=0; i<str.Length; i++){
                result.Add(char.ConvertToUtf32(str, i));
                if(char.IsHighSurrogate(str, i)){
                    i++;
                }
            }
            return result;
        }

        // return a unique label identifier
        int labelCounter = 0;
        public String GenerateLabel(){
            return $"${labelCounter++:00000}";
        }
        //-----------------------------------------------------------

        private string getFunctions(){
            StringBuilder builder = new StringBuilder();

            foreach(KeyValuePair<string, FunctionRow> entry in fTable ){
                
                if(entry.Value.getPrimitive()){
                    builder.Append($"  (import \"leviathan\" \"{entry.Key}\" (func ${entry.Key}");
                    int arity = entry.Value.getArity();
                    for(int i = 0; i< arity; i++){
                        builder.Append(" (param i32)"); // multiple params can be declared as (param i32 i32 i32)
                    }
                    builder.Append(" (result i32)))\n");
                }
            }
            string result = builder.ToString();
            return result;
        }
        
        private string getVariables(){ // define all global variables
            StringBuilder builder = new StringBuilder();
            foreach(var entry in gVar){
                builder.Append($"    (global ${entry} (mut i32) (i32.const 0))\n");
            }
            string result = builder.ToString();
            return result;
        }

        //-----------------------------------------------------------

        // add global variables and global functions
        public string Visit(Program node) { 

            return ";; WebAssembly text format code generated by "
                + "the leviathan compiler.\n\n"
                + "(module\n"
                + getFunctions()
                //+ "  (func (export \"start\")\n"
                + getVariables()
                + (Visit((dynamic) node[0]))
                //+ "  )\n" 
                + ")\n";
           
        }
        
        
        
        public string Visit(DefList node) {
            
            return VisitChildren((dynamic) node); // sons : (FunDef | VarDef)*

        }
        
        public string Visit(VarDef node){ // GLOBAL
            // DON'T DO ANYTHING
            return "";
        }

        public string Visit(FunDef node) { // sons : ParamList, var-def-list, stmt-list
            sb.Clear(); // clear the global buffer 
            var funName = node.AnchorToken.Lexeme;
            StringBuilder lb = new StringBuilder();
            if(funName=="main"){
                sb.Append($"    (func (export \"{funName}\")\n" );
                //sb.Append($"    (result i32)\n" );    
            } else {
                //sb.Append($"    (func ${funName} (result i32)\n" );
                sb.Append($"    (func ${funName} \n" );
            }
            // local variables temporales variables 
            // resetear variables temporales
            lb.Append(VisitChildren(node, funName));
            
            lb.Append("     i32.const 0\n");
            lb.Append(" )\n");
    
            // 
            return sb.ToString() + '\n' + lb.ToString();           
        }
        
        public string Visit(ParamList node, string fName){ // sons : NewIdentifiers*
            StringBuilder lb = new StringBuilder();
            idFather = "ParamList";
            sb.Append(VisitChildren( node, fName));                        
            sb.Append($"     (result i32)\n");
            
            //sb.Append($"     (local i32)\n");
            return lb.ToString();
        }
        
        public string Visit(VarDefList node, string fName){ // sons : VarDef*
            return VisitChildren( node, fName);
        }

        public string Visit(VarDef node, string fName){ //LOCAL son : IdDefList 
            return Visit((dynamic) node[0], fName);
        }

        public string Visit(IdDefList node, string fName){ // sons : NewIdentifiers*
            idFather = "IdDefList";
            return VisitChildren( node, fName);
        }

        public string Visit(NewIdentifier node, string fName){ // Add local variables no sons!
            // NewIdentifier can be a new local or global variable or a parameter of a function def
            var varName = node.AnchorToken.Lexeme;

            //if(parentNode.Equals(typeof(FunDef))){  // only enter
                if(idFather=="ParamList"){ // parameter, immediate father: paramlist, gf : fundef
                    return $"     (param ${varName} i32)\n" ; 
                } else { // local variable, immediate father: idDefList, gf : fundef
                    return $"     (local ${varName} i32)\n"; 
                }                       
            //} 
            //return "";
        }
        
        //
        public string Visit(IdList node, string fName){ // sons : Identifiers*
            return VisitChildren( node, fName);
        }

        public string Visit(Identifier node, string fName){ // I have no sons! =)
           var varName = node.AnchorToken.Lexeme;
           if(gVar.Contains(varName)){
            return $"       global.get ${varName} \n";
           } else {
            return $"       local.get ${varName} \n";
           }
           
            
        }
        //
        public string Visit(StmtList node, string fName){ // sons: StmtAssign, StmtFunCall, StmtWhile, StmtDoWhile, StmtIncr, StmtDecr, StmtIf, StmtBreak,StmtReturn, StmtEmpty
            return VisitChildren( node, fName);
        }

        public string Visit(StmtAssign node, string fName){ // sons: (+ - !) (* / %) (true false) (identifier, fun-call, array, lit) 
            var varName = node.AnchorToken.Lexeme;
            // definir si una es una variable local o global
            
            StringBuilder lb = new StringBuilder();

            if(gVar.Contains(varName)){ // variable global
                //lb.Append($"     (global.set \n");
                lb.Append(Visit((dynamic) node[0], fName)); 
                lb.Append($"       global.set ${varName} \n");
                //lb.Append($"    )\n");
            } else {                    // variable local
                //lb.Append($"     (local.set \n");
                lb.Append(Visit((dynamic) node[0], fName)); 
                lb.Append($"       local.set ${varName}\n");
                //lb.Append($"    )\n");
            }
            return lb.ToString();
        }

        // LITS
        public string Visit(Int_Literal node, string fName){ 
            var catchVal = node.AnchorToken.Lexeme;
            return $"       i32.const {catchVal}\n";
        }

        public string Visit(Char_Literal node, string fName){ 
            string catchVal = node.AnchorToken.Lexeme;
            
            if(catchVal[1] != '\\' ) {
                var literal = AsCodePoints(catchVal);
                return $"       i32.const {literal[1]} \n";
            }else
            {
                switch(catchVal[2]){
                    case 'n':
                        return $"       i32.const 10 \n";
                    case 'r':
                        return $"       i32.const 13 \n";
                    case 't':
                        return $"       i32.const 9\n";
                    case '\\':
                        return $"       i32.const 92 \n";
                    case '\'':
                        return $"       i32.const 39 \n";
                    case '\"':
                        return $"       i32.const 34 \n";
                    case 'u':
                        string hex = catchVal.Substring(3, 6);
                        //Console.WriteLine(hex);
                        int val = Convert.ToInt32(hex, 16);
                        //int val = Int32.Parse(hex);
                        return $"       i32.const {val} \n";
                    default:
                        Console.WriteLine("Default case");
                        return " ";
                }
            }
            //return "";
            
        }

        // arrays and string literals are stored in handles (a js array)
        // and are identified in WAT code by their generated label
        public string Visit(String_Literal node, string fName){ 
            
            var catchVal = node.AnchorToken.Lexeme;
            IList<int> codes = AsCodePoints(catchVal);           
            StringBuilder lb = new StringBuilder();
        
            var t = GenerateLabel(); 
            
            // append to the top of the function definition the 
            // new temporal variable for the array
            sb.Append($"     (local {t} i32)  \n");
    
            // append to the local sb the new handle,
            // with the new temporal variable
            lb.Append($"       i32.const 0 \n ");
            lb.Append($"       call $new \n");
            lb.Append($"       local.set {t}\n "); // TODO: resetear la secuencia de las variables locales
            
            // for each children node of expr-list
            for(int i = 1; i <= catchVal.Length - 2 ; i++)
            {
                 // retrieve the temporal handle 
                lb.Append($"     local.get {t} \n");
                if(catchVal[i] != '\\' ) {
                     //IList<int> codes = AsCodePoints(catchVal[i]);
                     var code= codes[i];
                     
                        //var literal = AsCodePoints(catchVal[i].ToString());     
                        // retrieve the element to be added to the array
                        lb.Append($"       i32.const {code} \n");
                        lb.Append($"       call $add \n");
                        lb.Append("       drop \n");    
                      
                }
                else
                {
                    switch(catchVal[i+1]){
                        case 'n':
                            lb.Append($"       i32.const 10 \n");
                            lb.Append($"       call $add \n");
                            lb.Append("       drop \n");
                            i++;
                            break;
                        
                        case 'r':
                            lb.Append($"      i32.const 13 \n");
                            lb.Append($"      call $add \n");
                            lb.Append("      drop \n");
                            i++;
                            break;
                        case 't':
                            lb.Append($"       i32.const 9\n");
                            lb.Append($"       call $add \n");
                            lb.Append("       drop \n");
                            i++;
                            break;
                        case '\\':
                            lb.Append($"       i32.const 92 \n");
                            lb.Append($"       call $add \n");
                            lb.Append("       drop \n");
                            i++;
                            break;
                        case '\'':
                            lb.Append($"       i32.const 39 \n");
                            lb.Append($"       call $add \n");
                            lb.Append("       drop \n");
                            i++;
                            break;
                        case '\"':
                            lb.Append($"       i32.const 34 \n");
                            lb.Append($"       call $add \n");
                            lb.Append("       drop \n");
                            i++;
                            break;
                        case 'u':
                            string hex = catchVal.Substring(i+2, 6);
                            //Console.WriteLine(hex);
                            int val = Convert.ToInt32(hex, 16);
                            i = i + 7;
                            lb.Append($"       i32.const {val} \n");
                            lb.Append($"       call $add \n");
                            lb.Append("       drop \n");
                            break;
                        default:
                            Console.WriteLine("Default case");
                            break;
                        }
                }



            }
                // retrieve the element to be added to the array
                //lb.Append($"      i32.const {n}\n");

                // call the add function of the leviathanAPI
                // so that it can be added to the array object
            //lb.Append($"      call $add \n");

            // drop the last element in the stack
            
            lb.Append($"       local.get {t} \n");
            // return local string builder
            return lb.ToString();
        }

        // TRUE && FALSE
        public string Visit(True node, string fName){
            // I HAVE NO KIDS! =)        
              return "       i32.const 1\n"; 
        }

        public string Visit(False node, string fName){
            // I HAVE NO KIDS! =)
             return "       i32.const 0\n";
        }

        public string Visit(UnEqual node, string fName){
            return VisitChildren(node, fName)
             + "       i32.ne\n";
            
        }
        
        public string Visit(Array node, string fName){ // son: expr-list
            StringBuilder lb = new StringBuilder();
            
            //funCallName = "array";
            var t = GenerateLabel(); 
            
            // append to the top of the function definition the 
            // new temporal variable for the array
            sb.Append($"     (local {t} i32)  \n");
            
            // append to the local sb the new handle,
            // with the new temporal variable
            lb.Append($"       i32.const 0 \n ");
            lb.Append($"       call $new \n");
            lb.Append($"       local.set {t} \n"); // TODO: resetear la secuencia de las variables locales

            // for each children node of expr-list
            foreach(var n in node[0]){

                // retrieve the temporal handle 
                lb.Append($"       local.get {t} \n");

                // retrieve the element to be added to the array
                lb.Append(Visit((dynamic) n, fName));

                // call the add function of the leviathanAPI
                // so that it can be added to the array object
                lb.Append($"       call $add \n");

                // drop the last element in the stack
                lb.Append("       drop \n");

            }
            lb.Append($"       local.get {t} \n");
            // return local string builder
            return lb.ToString();
        }
        
         // OpAdd
        public string Visit(Neg node, string fName){

            if(childrenCounter(node)>1){// substraction
                return VisitChildren(node, fName)
                + "       i32.sub\n";
            } else { // unary operator

                return " i32.const 0 \n" 
                + VisitChildren(node, fName)
                + "       i32.sub\n";
            }
        }

        public string Visit(Plus node, string fName){
            if(childrenCounter(node)>1){// addition
                return VisitChildren(node, fName)
                + "       i32.add\n";
            } else { // unary operator
                return " i32.const 0 \n" 
                + VisitChildren(node, fName)
                + "       i32.add\n";
            //+ "       i32.sub\n";
            }
        }

        public string Visit(Not node, string fName){ // !
            return VisitChildren( node, fName)
            + "       i32.eqz\n";
        }

        // OpMul
        public string Visit (Mul node, string fName){
            return VisitChildren( node, fName)
            +"       i32.mul\n";
        }
        public string Visit (Div node, string fName){
            return VisitChildren( node, fName)
            +"       i32.div_s\n";
        }
        public string Visit (Mod node, string fName){
            return VisitChildren( node, fName)
            +"       i32.rem_s\n";
        }
        
        // OpRel
        // compare operators
        public string Visit(Less node, string fName){
            return VisitChildren( node , fName)
            + "       i32.lt_s\n";
        }

        public string Visit(Less_Equal node, string fName){
            return VisitChildren( node, fName)
            +"       i32.le_s\n";
        }

        public string Visit(More node, string fName){
            return VisitChildren( node, fName)
            +"       i32.gt_s\n";
        }

        public string Visit(More_Equal node, string fName){
            return VisitChildren( node, fName)
            + "       i32.ge_s\n";
        }

        public string Visit(Equal node, string fName){
            return VisitChildren(node, fName) 
            + "       i32.eq\n";
        }

        // OpUnary
        public string Visit (StmtFunCall node, string fName){ //sons:  exprlist
            string funName = node.AnchorToken.Lexeme;
            
            return VisitChildren(node, fName) // puts args before function call
            + $"       call ${funName}\n"
            + "       drop \n";
            //es necesario este drop?
            
        }

        
        public string Visit (FunCall node, string fName){ //sons:  exprlist
            string funName = node.AnchorToken.Lexeme;
            return VisitChildren(node, fName) // puts args before function call
            +$"       call ${funName}\n";
        }

        public string Visit (StmtIncr node, string fName){
            var varName = node.AnchorToken.Lexeme;
            StringBuilder lb = new StringBuilder();

            if(gVar.Contains(varName)){
                lb.Append($"       global.get ${varName} \n");
                lb.Append($"       i32.const 1 \n");
                lb.Append($"       i32.add \n");
                lb.Append($"       global.set ${varName} \n");
            } else {
                lb.Append($"       local.get ${varName} \n");
                lb.Append($"       i32.const 1 \n");
                lb.Append($"       i32.add \n");
                lb.Append($"       local.set ${varName} \n");
            }

            return lb.ToString();
            
        }
        public string Visit (StmtDecr node, string fName){
            var varName = node.AnchorToken.Lexeme;
            StringBuilder lb = new StringBuilder();

            if(gVar.Contains(varName)){
                lb.Append($"       global.get ${varName} \n");
                lb.Append($"       i32.const 1 \n");
                lb.Append($"       i32.sub \n");
                lb.Append($"       global.set ${varName} \n");
            } else {
                lb.Append($"       local.get ${varName} \n");
                lb.Append($"       i32.const 1 \n");
                lb.Append($"       i32.sub \n");
                lb.Append($"       local.set ${varName} \n");
            }
            return lb.ToString();
            
        }

        public string Visit (StmtBreak node, string fName){ //sons: 
            //No tiene hijos
            //Console.WriteLine(inLoop);
            //hacer un pick de la pila
            var label = pila.Peek();
            return$"       br {label}\n";            
        }
           //No tiene hijos
        public string Visit (StmtReturn node, string fName){ //sons:  maybe
            return Visit((dynamic) node[0], fName)
            + $"       return\n";
        }
        public string  Visit (StmtEmpty node, string fName){ //sons:  
           //DON'T DO ANYTHING
           //regresar una cadena vacia
           return " ";
        }

        public string Visit(StmtWhile node, string fName){ //Duda no sabemos si esta bien
            StringBuilder lb = new StringBuilder();

            var label1 = GenerateLabel();
            var label2 = GenerateLabel();
            pila.Push(label1);
            //

            lb.Append($"       block {label1}\n");
            lb.Append($"       loop {label2}\n");
            lb.Append(Visit((dynamic) node[0], fName));
            lb.Append($"       i32.eqz\n");
            lb.Append($"       br_if {label1}\n");
            lb.Append(Visit((dynamic) node[1], fName));
            lb.Append($"       br {label2}\n");
            lb.Append($"       end\n"); //loop
            lb.Append($"       end\n"); //block
            //antes de hacer el return hacer un pop del label1 = pila.pop
            pila.Pop();
            //var result = sb.ToString();
            return lb.ToString();
        }

        public string Visit(StmtDoWhile node , string fName){ //Duda igual
            StringBuilder lb = new StringBuilder();
            var label1 = GenerateLabel();            
            var label2 = GenerateLabel();
            pila.Push(label1);
            lb.Append($"       block {label1}\n"); //do
            lb.Append($"       loop {label2}\n"); //loop
            lb.Append(Visit((dynamic) node[0], fName));
            lb.Append(Visit((dynamic) node[1], fName));
            //sb.Append($"     i32.eqz \n");
            lb.Append($"       br_if {label2}\n"); //este era label1
            //sb.Append($"     br {label2}\n");
            lb.Append($"       end\n"); //loop
            lb.Append($"       end\n"); //block 
            pila.Pop();
            return lb.ToString();
        }


        
        public string Visit(StmtIf node, string fName){
            StringBuilder lb = new StringBuilder();
            // evaluate condition
            lb.Append(Visit((dynamic) node[0], fName));
            lb.Append($"       if\n");
            
            // execute stmtlist
            lb.Append(Visit((dynamic) node[1], fName));
            
            // determine if StmtIf has an else son 
            bool hasElse = false;
            if(childrenCounter(node)>3){
                hasElse = true;
            }

            // elseiflist is appended here
            lb = Visit((dynamic) node[2], fName, lb, hasElse); 

            // add the last else statement if there is one
            if(hasElse){

                if(Visit((dynamic) node[2], fName)){ // determine if there is 
                                                     // an elseiflist
                    lb.Append(Visit((dynamic) node[3], fName));   // else
                    // close all ifs
                    for(int i=0; i<childrenCounter(node[2]); i++){
                        lb.Append("       end\n");
                    }
                } else {
                    lb.Append("       else\n");
                    lb.Append(Visit((dynamic) node[3], fName));  // else
                }      
            } else {
                if(childrenCounter(node[2])>0){
                    for(int i=0; i<childrenCounter(node[2])-1; i++){
                        lb.Append("       end\n");
                    }
                }
            }
            lb.Append($"       end         \n");          
            return lb.ToString();
        }
        
        public StringBuilder Visit(ElseIfList node, string fName, StringBuilder lb, bool hasElse){ // sons : elif*
            if(childrenCounter(node)>0){
                lb.Append($"       else\n");    // outer else           
                int nidIfCtr = childrenCounter(node);
                for(int i=0; i<nidIfCtr; i++){
                    lb.Append(Visit((dynamic)node[i], fName)); // add multiple if statement    
                    if(i!=nidIfCtr-1){
                        lb.Append("       else\n");
                    } else {
                        if(hasElse){
                            lb.Append("       else\n");
                        } else {
                            lb.Append("       end\n");
                        }
                    }            
                    
                }  
            }
            return lb;
        }

        public bool Visit(ElseIfList node, string fname){
            if(childrenCounter(node)>0){
                return true;
            }
            return false;
        }

        public string Visit(Elif node, string fName){
            StringBuilder lb = new StringBuilder();
            // evaluate condition
            lb.Append(Visit((dynamic)node[0], fName));
            lb.Append($"        if\n");
            // execute statement        
            lb.Append(Visit((dynamic)node[1], fName));
            //lb.Append($"        end\n");
            return lb.ToString();
        }


         //stmt list 
        public string Visit(Else node, string fName){
            return VisitChildren(node, fName);         
        }
        
        public string Visit(ExprOr node, string fName){
            return VisitChildren( node, fName) 
            + $"       i32.or \n";
        }

        public string  Visit(ExprAnd node, string fName){
            return VisitChildren( node, fName) 
            + $"       i32.and \n";
        }


        public string Visit(ExprList node, string fName){ // sons: LITERALS* IDENTIFIER* FUNCALL* ARRAY? EMPTY
           // Load args or array elements 
           return VisitChildren(node, fName);

        }

        public string Visit(Condition node, string fName){
            return Visit((dynamic) node[0], fName);
        }

        public string Visit(LoopCondition node, string fName){
            return  Visit((dynamic) node[0], fName);
        }

        // auxiliary function to return the number of children of a node
        public int childrenCounter(Node node){
            int childCtr = 0;
            foreach(var n in node){
                childCtr++;
            }
            return childCtr;
        }
        
        public string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
            
        }

        public string VisitChildren(Node node, string fName) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n, fName));
            }
            return sb.ToString();
            
        }
    
    }
}
