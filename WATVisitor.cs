/*
    Levithan Compiler -  WebAssembly text file (WAT) code generator.

    Camila Rovirosa A01024192
    Eduardo Badillo A01020716
    Isabel Maqueda  A01652906

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Leviathan {

    class WATVisitor {

        // controller variables
        public int inLoop = 0;
        string funCallName;
        string idFather = "";
        int ifFlag = 0;
        Node parentNode;

        //

        public FunctionTable fTable{
            get; 
            private set;
        }
        public HashSet<string> gVar;
        
        public WATVisitor(FunctionTable functionTable, HashSet<string> globalVariables){
            this.fTable = functionTable;
            this.gVar = globalVariables;
        }

        StringBuilder sb = new StringBuilder();
        
        //Auxiliary methods
        
        
        // convert str to utf-32
        public IList<int> AsCodePoints(string str){
            var result = new List<int>(str.length);
            for(int i=0; i<str.Length; i++){
                result.Add(char.ConvertToUtf32(str, i));
                if(char.isHighSurrogate(str, i)){
                    i++;
                }
            }
            return result;
        }

        // return a unique label identifier
        int labelCounter = 0;
        public String GenerateLabel(){
            return $"{labelCounter++:00000}";
        }
        //-----------------------------------------------------------

        // add global variables and global functions
        public string Visit(Program node) { 
        
            sb.Append(";; WebAssembly text format code generated by the leviathan compiler.\n"
                + "(module\n");
                sb.Append(getFunctions());
                sb.Append("  (func (export \"start\")\n");
                sb.Append(getVariables());
    
                sb.Append("  )\n");
                sb.Append(")\n");
                sb.Append(Visit((dynamic) node[0]));

                return sb.ToString();
        }
        
        private string getFunctions(){
            StringBuilder builder = new StringBuilder();

            foreach(KeyValuePair<string, FunctionRow> entry in fTable ){
                
                if(entry.Value.getPrimitive()){
                    builder.Append($"  (import \"leviathan\" \"{entry.Key}\" (func ${entry.Key}");
                    int arity = entry.Value.getArity();
                    for(int i = 0; i< arity; i++){
                        builder.Append(" (param i32)"); // multiple params can be declared as (param i32 i32 i32)
                    }
                    builder.Append(" (result i32)))\n");
                }
            }
            string result = builder.ToString();
            return result;
        }
        
        private string getVariables(){ // define all global variables
            StringBuilder builder = new StringBuilder();
            foreach(var entry in gVar){
                builder.Append($"    (global ${entry} (mut i32) (i32.const 0))\n");
            }
            string result = builder.ToString();
            return result;
        }

        //-----------------------------------------------------------
        
        public void Visit(DefList node) {
            VisitChildren((dynamic) node); // sons : (FunDef | VarDef)*
        }
        
        public void Visit(VarDef node){ // GLOBAL
            // DON'T DO ANYTHING
        }

        public void Visit(FunDef node) { // sons : ParamList, var-def-list, stmt-list
            var funName = node.AnchorToken.Lexeme;
            funCallName = funName;
            parentNode = (dynamic) node;
            //func $plus1
            sb.Append($"    (func ${funName} \n" );
            /*
            for(int i = 0; i< arity; i++){
                sb.Append(" (param i32)");
            }*/
            //sb.Append(" (result i32)\n");
            VisitChildren(node, funName);
            
            sb.Append("     return\n");
            sb.Append("     end\n");
            sb.Append("     i32.const 0\n");
            sb.Append(" )\n");
        
            //Visit((dynamic) node[0], funName); // ParamList
            //Visit((dynamic) node[1], funName); // var-def-list
            //Visit((dynamic) node[2], funName); // stmt-list             
        }
        
        public void Visit(ParamList node, string fName){ // sons : NewIdentifiers*
            idFather = "ParamList";
            VisitChildren( node, fName);
            sb.Append($"     (result i32)\n");
        }
        
        public void Visit(VarDefList node, string fName){ // sons : VarDef*
            VisitChildren( node, fName);
        }

        public void Visit(VarDef node, string fName){ //LOCAL son : IdDefList 
            Visit((dynamic) node[0], fName);
        }

        public void Visit(IdDefList node, string fName){ // sons : NewIdentifiers*
            idFather = "IdDefList";
            return VisitChildren( node, fName);
        }

        public void Visit(NewIdentifier node, string fName){ // Add local variables no sons!
            // NewIdentifier can be a new local or global variable or a parameter of a function def
            var varName = node.AnchorToken.Lexeme;

            if(parentNode.Equals(typeof(FunDef))){  // only enter
                if(idFather=="ParamList"){ // parameter, immediate father: paramlist, gf : fundef
                    sb.Append($"     (param ${varName} i32)\n");
                } else { // local variable, immediate father: idDefList, gf : fundef
                    sb.Append($"     (local ${varName} i32)\n");
                }                       
            } 
        }
        
        // DUDA
        public void Visit(IdList node, string fName){ // sons : Identifiers*
            return VisitChildren( node, fName);
        }

        public void Visit(Identifier node, string fName){ // I have no sons! =)
           var varName = node.AnchorToken.Lexeme;

           sb.Append($"     (local.get ${varName} i32)\n");
            
        }
        //
        public void Visit(StmtList node, string fName){ // sons: StmtAssign, StmtFunCall, StmtWhile, StmtDoWhile, StmtIncr, StmtDecr, StmtIf, StmtBreak,StmtReturn, StmtEmpty
            VisitChildren( node, fName);
        }

        public void Visit(StmtAssign node, string fName){ // sons: (+ - !) (* / %) (true false) (identifier, fun-call, array, lit) 
            parentNode = (dynamic)node;
            var varName = node.AnchorToken.Lexeme;
            // definir si una es una variable local o global
            if(gVar.Contains(varname)){ // variable global
                sb.Append($"     (global.set \n");
                Visit((dynamic) node[0], fName); 
                sb.Append($"    )\n");
            } else {                    // variable local
                sb.Append($"     (local.set \n");
                Visit((dynamic) node[0], fName); 
                sb.Append($"    )\n");
            }
        }

        // LITS
        public void Visit(Int_Literal node, string fName){ 
            var catchVal = node.AnchorToken.Lexeme;
            sb.Append($"     i32.const {catchVal}\n");
        }

        public void Visit(Char_Literal node, string fName){ 
            var catchVal = node.AnchorToken.Lexeme;
            var literal = AsCodePoints(Char.ToString(catchVal));
            sb.Append($"     i32.const {literal}");
        }

        // arrays and string literals are stored in handles (a js array)
        // and are identified in WAT code by their generated labels
        public void Visit(String_Literal node, string fName){ 
            /*
            var catchVal = node.AnchorToken.Lexeme;
            IList<int> codes = AsCodePoints(catchVal);
            var t = GenerateLabel();
            //pregunta maestro, lo que se quiere usar es el api de leviathan, como importar o como 
            //mandar a llamar 
            //t = new(0);
            foreach (int code in codes)
            {
                //add(t, code);
            }
            sb.Append($"     i32.const {t}");*/
        }

        // TRUE && FALSE
        public void Visit(True node, string fName){
            // I HAVE NO KIDS! =)        
              sb.Append("    i32.const 1\n"); 
        }

        public void Visit(False node, string fName){
            // I HAVE NO KIDS! =)
              sb.Append("    i32.const 0\n");
        }

        public void Visit(UnEqual node, string fName){
            VisitChildren(node, fName);
            sb.Append("      i32.ne\n");
        }

        public void Visit(Array node, string fName){ // son: expr-list

            //pregunta sobre array mostrar como ejemplo https://openhome.cc/eGossip/WebAssembly/Array.html
            funCallName = "array";
            var t = GenerateLabel();
            t = new(0);
            sb.Append($"     i32.const {t}");
            Visit((dynamic) node[0], fName); 
        }
         // OpAdd
        public void Visit(Neg node, string fName){
            //sb.Append("      i32.const 0\n"); // duda
            VisitChildren( node, fName); 
            sb.Append("      i32.sub\n");
        }

        public void Visit(Plus node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.add\n");
        }

        public void Visit(Not node, string fName){ // !
            VisitChildren( node, fName);
            sb.Append("      i32.eqz\n");
        }

        // OpMul
        public void Visit (Mul node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.mul\n");
        }
        public void Visit (Div node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.div\n");
        }
        public void Visit (Mod node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.rem_s\n");
        }
        
        // OpRel
        public void Visit(Less node, string fName){
            VisitChildren( node , fName);
            sb.Append("      i32.lt_s\n");
        }

        public void Visit(Less_Equal node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.le_s\n");
        }

        public void Visit(More node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.gt_s\n");
        }

        public void Visit(More_Equal node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.ge_s\n");
        }

        public void Visit(Equal node, string fName){
            VisitChildren(node, fName);
            sb.Append("      i32.eq\n");
        }

        // OpUnary
        public void Visit (StmtFunCall node, string fName){ //sons:  exprlist
            string funName = node.AnchorToken.Lexeme;
            funCallName = funName;
            parentNode = (dynamic)node;
            VisitChildren(node, fName); // puts args before function call
            sb.Append($"      call ${funName}\n");
        }

        
        public void Visit (FunCall node, string fName){ //sons:  exprlist
            string funName = node.AnchorToken.Lexeme;
            funCallName = (dynamic)funName;
            VisitChildren(node, fName); // puts args before function call
            sb.Append($"      call ${funName}\n");
        }

        public void Visit (StmtIncr node, string fName){
            var varName = node.AnchorToken.Lexeme;
            if(gVar.Contains(varName)){
                sb.Append($"     global.get ${varName} \n");
                sb.Append($"     i32.const 1 \n");
                sb.Append($"     i32.add \n");
            } else {
                sb.Append($"     local.get ${varName} \n");
                sb.Append($"     i32.const 1 \n");
                sb.Append($"     i32.add \n");
            }
            
        }
        public void Visit (StmtDecr node, string fName){
            var varName = node.AnchorToken.Lexeme;

            if(gVar.Contains(varName)){
                sb.Append($"     global.get ${varName} \n");
                sb.Append($"     i32.const 1 \n");
                sb.Append($"     i32.sub \n");
            } else {
                sb.Append($"     local.get ${varName} \n");
                sb.Append($"     i32.const 1 \n");
                sb.Append($"     i32.sub \n");
            }
            
        }

        public void Visit (StmtBreak node, string fName){ //sons: 
        //No tiene hijos
            //Console.WriteLine(inLoop);
            
        }
           //No tiene hijos
        public void Visit (StmtReturn node, string fName){ //sons:  maybe
            Visit((dynamic) node[0], fName);
            sb.Append($"     return\n");
        }
        public void Visit (StmtEmpty node, string fName){ //sons:  
           //DON'T DO ANYTHING
        }

        public void Visit(StmtWhile node, string fName){ //Duda no sabemos si esta bien
            /*inLoop++;
            Visit((dynamic) node[0], fName);
            Visit((dynamic) node[1], fName);
            inLoop--;*/
            var label1 = GenerateLabel();
            var label2 = GenerateLabel();
            sb.Append($"     block ${label1}\n");
            sb.Append($"     loop ${label2}\n");
            Visit((dynamic) node[0], fName);
            sb.Append($"     i32.eqz\n");
            sb.Append($"     br_if ${label1}\n");
            Visit((dynamic) node[1], fName);
            sb.Append($"     br ${label2}\n");
            sb.Append($"     end\n"); //loop
            sb.Append($"     end\n"); //block
        }

        public void Visit(StmtDoWhile node , string fName){ //Duda igual
            /*inLoop++;
            VisitChildren(node, fName);
            inLoop--;*/
            var label1 = GenerateLabel();
            var label2 = GenerateLabel();
            sb.Append($"     block ${label1}\n");
            sb.Append($"     loop ${label2}\n");
            Visit((dynamic) node[1], fName);
            sb.Append($"     i32.eqz\n");
            sb.Append($"     br_if ${label1}\n");
            Visit((dynamic) node[0], fName);
            sb.Append($"     br ${label2}\n");
            sb.Append($"     end\n"); //loop
            sb.Append($"     end\n"); //block
        }

        public void Visit(StmtIf node, string fName){// a llorar con el profe DUDA
            // evaluate condition
            Visit((dynamic) node[0], fName);
            sb.Append($"     if\n");
            
            // execute stmtlist
            Visit((dynamic) node[1], fName);
            
            // else if list 
            Visit((dynamic) node[2], fName); 
            
            // determine if StmtIf has an else son 
            if(childrenCounter(node)>3){
                Visit((dynamic) node[3], fName);
            }
            sb.Append($"     end         \n");          
            sb.Append($"     i32.const 0 \n");          
        }

        public void Visit(ElseIfList node, string fName){ // sons : elif*
            if(childrenCounter(node)>0){
                ifFlag = 1; // activate ifFlag to tell that else statement has been appended
                sb.Append($"    else");
                VisitChildren(node, fName); // add multiple if statements nested in the else "elifs"*
            }
        }

        public void Visit(Elif node, string fName){
            // evaluate condition
            Visit(node[0], fName);

            sb.Append($"        if\n");

            // execute statement        
            Visit(node[1], fName);

            sb.Append($"        end\n");
        }

        public void Visit(Else node, string fName){
            if(ifFlag){
                VisitChildren(node, fName);         
            } else {
                sb.Append($"     else\n");
                VisitChildren(node, fName);         
            }
            ifFlag = 0;
        }

        public void Visit(ExprOr node, string fName){
            VisitChildren( node, fName);
            sb.Append($"     i32.or \n");
        }

        public void Visit(ExprAnd node, string fName){
            VisitChildren( node, fName);
            sb.Append($"     i32.and \n");
        }


         //stmt list 

        //

        public void Visit(ExprList node, string fName){ // sons: LITERALS* IDENTIFIER* FUNCALL* ARRAY? EMPTY
           
           // Load args or array elements 
           VisitChildren(node, fName);
           /*
           if(funCallName!="array"){ // father is stmtfuncall

           } else {                  // father is array
            VisitChildren(node, fName); 
           }
           */

        }

        public void Visit(Condition node, string fName){
            Visit((dynamic) node[0], fName);
        }

        public void Visit(LoopCondition node, string fName){
            Visit((dynamic) node[0], fName);
        }

        // auxiliary function to return the number of children of a node
        public int childrenCounter(Node node){
            int childCtr = 0;
            foreach(var n in node){
                childCtr++;
            }
            return childCtr;
        }
        
        public void VisitChildren(Node node) {
            
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            
        }

        public void VisitChildren(Node node, string fName) {
            
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n, fName));
            }
            
        }
    
    }
}
