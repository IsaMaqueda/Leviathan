/*
    Levithan Compiler -  WebAssembly text file (WAT) code generator.

    Camila Rovirosa A01024192
    Eduardo Badillo A01020716
    Isabel Maqueda  A01652906

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Leviathan {

    class WATVisitor {

        //Globales table;

        public FunctionTable fTable{
            get; 
            private set;
        }
        public HashSet<string> gVar;
        /*
        public WATVisitor(Globales table){
            this.table = table;
        }*/
        
        public WATVisitor(FunctionTable functionTable, HashSet<string> globalVariables){
            this.fTable = functionTable;
            this.gVar = globalVariables;
        }
        
        //-----------------------------------------------------------
        

        /*public WATVisitor(SymbolTable table) {
            this.table = table;
        }*/

        private StringBuilder builder = new StringBuilder();

        // add global variables and global functions
        public string Visit(Program node) { 
            
            builder.AppendLine(";; WebAssembly text format code generated by ");
            builder.Append(
                "the Leviathan compiler.\n\n"
                + "(module\n");
            getFunctions();
            builder.Append(
                "  (func (export \"start\")\n"   
                + "  )\n"
                + ")\n");
            //visits
            // + Visit((dynamic) node[0])
            // + Visit((dynamic) node[1])
            //+ Visit((dynamic) node[0])
              //  + Visit((dynamic) node[1])
               // + "  )\n"
                //+ ")\n";
            string result = builder.ToString();
            return result;
        }

        private void getFunctions(){
            foreach(KeyValuePair<string, FunctionRow> entry in fTable){
                builder.Append($"  (import \"leviathan\" \"{entry.Key}\" (func ${entry.Key}");
                int arity = entry.Value.getArity();
                for(int i = 0; i< arity; i++){
                    builder.Append(" (param i32)");
                }
                builder.Append(" (result i32)))\n");
            }
        }

        //-----------------------------------------------------------
        /*
        public string Visit(DefList node) {
            // The code for the local variable declarations is
            // generated directly from the symbol table, not from
            // the AST nodes.
            foreach (var entry in table) {
                sb.Append($"    (local ${entry.Key} i32)\n");
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        public string Visit(StatementList node) {
            return VisitChildren(node);
        }

        //-----------------------------------------------------------
        public string Visit(Assignment node) {
            return Visit((dynamic) node[0])
                + $"    local.set ${node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(Print node) {
            return Visit((dynamic) node[0])
                + $"    call ${PrintInstructions[node.ExpressionType]}\n";
        }

        //-----------------------------------------------------------
        public string Visit(If node) {
            return Visit((dynamic) node[0])
                + "    if\n"
                + Visit((dynamic) node[1])
                + "    end\n";
        }

        //-----------------------------------------------------------
        public string Visit(Identifier node) {
            return $"    local.get ${node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(IntLiteral node) {
            return $"    i32.const {node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(True node) {
            return "    i32.const 1\n";
        }

        //-----------------------------------------------------------
        public string Visit(False node) {
            return "    i32.const 0\n";
        }

        //-----------------------------------------------------------
        public string Visit(Neg node) {
            return "    i32.const 0\n"
                + Visit((dynamic) node[0])
                + "    i32.sub\n";
        }

        //-----------------------------------------------------------
        public string Visit(And node) {
            return VisitBinaryOperator("i32.and", node);
        }

        //-----------------------------------------------------------
        public string Visit(Less node) {
            return VisitBinaryOperator("i32.lt_s", node);
        }

        //-----------------------------------------------------------
        public string Visit(Plus node) {
            return VisitBinaryOperator("i32.add", node);
        }

        //-----------------------------------------------------------
        public string Visit(Mul node) {
            return VisitBinaryOperator("i32.mul", node);
        }

        //-----------------------------------------------------------
        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        string VisitBinaryOperator(string op, Node node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + $"    {op}\n";
        }
        */
    }
}
