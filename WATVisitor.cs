/*
    Levithan Compiler -  WebAssembly text file (WAT) code generator.

    Camila Rovirosa A01024192
    Eduardo Badillo A01020716
    Isabel Maqueda  A01652906

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Leviathan {

    class WATVisitor {

        //Globales table;
        public int inLoop = 0;
        string funCallName;
        Node parentNode;

        public FunctionTable fTable{
            get; 
            private set;
        }
        public HashSet<string> gVar;
        
        public WATVisitor(FunctionTable functionTable, HashSet<string> globalVariables){
            this.fTable = functionTable;
            this.gVar = globalVariables;
        }

        StringBuilder sb = new StringBuilder();
        
        //Auxiliary methods
        
        
        // convert str to utf-32
        public IList<int> AsCodePoints(string str){
            var result = new List<int>(str.length);
            for(int i=0; i<str.Length; i++){
                result.Add(char.ConvertToUtf32(str, i));
                if(char.isHighSurrogate(str, i)){
                    i++;
                }
            }
            return result;
        }

        // return a unique label identifier
        int labelCounter = 0;
        public String GenerateLabel(){
            return $"{labelCounter++:00000}";
        }
        //-----------------------------------------------------------

        // add global variables and global functions
        public string Visit(Program node) { 
        
            sb.Append(";; WebAssembly text format code generated by the leviathan compiler.\n"
                + "(module\n");
                sb.Append(getFunctions());
                sb.Append("  (func (export \"start\")\n");
                sb.Append(getVariables());
    
                sb.Append("  )\n");
                sb.Append(")\n");
                sb.Append(Visit((dynamic) node[0]));

                return sb.ToString();
        }
        
        private string getFunctions(){
            StringBuilder builder = new StringBuilder();

            foreach(KeyValuePair<string, FunctionRow> entry in fTable ){
                //Console.WriteLine(entry.Value.getPrimitive());
                if(entry.Value.getPrimitive()){
                    builder.Append($"  (import \"leviathan\" \"{entry.Key}\" (func ${entry.Key}");
                    int arity = entry.Value.getArity();
                    for(int i = 0; i< arity; i++){
                        builder.Append(" (param i32)"); // multiple params can be declared as (param i32 i32 i32)
                    }
                    builder.Append(" (result i32)))\n");
                }
            }
            string result = builder.ToString();
            return result;
        }
        
        private string getVariables(){ // define all global variables
            StringBuilder builder = new StringBuilder();
            foreach(var entry in gVar){
                builder.Append($"    (global ${entry} (mut i32) (i32.const 0))\n");
            }
            string result = builder.ToString();
            return result;
        }

        //-----------------------------------------------------------
        
        public void Visit(DefList node) {
            VisitChildren((dynamic) node); // sons : (FunDef | VarDef)*
        }
        
        public void Visit(VarDef node){ // GLOBAL
            // DON'T DO ANYTHING
        }

        public void Visit(FunDef node) { // sons : ParamList, var-def-list, stmt-list
            var funName = node.AnchorToken.Lexeme;
            funCallName = funName;
            parentNode = (dynamic) node;
            //func $plus1
            sb.Append($"    (func ${funName} \n" );
            /*
            for(int i = 0; i< arity; i++){
                sb.Append(" (param i32)");
            }*/
            //sb.Append(" (result i32)\n");
            VisitChildren(node, funName);
            sb.Append(" )\n");
        
            //Visit((dynamic) node[0], funName); // ParamList
            //Visit((dynamic) node[1], funName); // var-def-list
            //Visit((dynamic) node[2], funName); // stmt-list             
        }
        
        public void Visit(ParamList node, string fName){ // sons : NewIdentifiers*
            VisitChildren( node, fName);
            sb.Append($"     (result i32)");
        }
        
        public void Visit(VarDefList node, string fName){ // sons : VarDef*
            VisitChildren( node, fName);
        }

        public void Visit(VarDef node, string fName){ //LOCAL son : IdDefList 
            parentNode = (dynamic) node;
            Visit((dynamic) node[0], fName);
        }

        public void Visit(IdDefList node, string fName){ // sons : NewIdentifiers*
            return VisitChildren( node, fName);
        }

        public void Visit(NewIdentifier node, string fName){ // Add local variables no sons!
            var varName = node.AnchorToken.Lexeme;

            if(parentNode.Equals(typeof(FunDef))){
                
                sb.Append($"     (param ${varName}i32)\n");
                    
            } else {
                 sb.Append($"     (local ${varName} i32)\n");
            }
        }
        
        // DUDA
        public void Visit(IdList node, string fName){ // sons : Identifiers*
            return VisitChildren( node, fName);
        }

        public void Visit(Identifier node, string fName){ // I have no sons! =)
           var varName = node.AnchorToken.Lexeme;

           sb.Append($"     (local.get ${varName} i32)\n");
            
        }
        //
        public void Visit(StmtList node, string fName){ // sons: StmtAssign, StmtFunCall, StmtWhile, StmtDoWhile, StmtIncr, StmtDecr, StmtIf, StmtBreak,StmtReturn, StmtEmpty
            VisitChildren( node, fName);
        }

        public void Visit(StmtAssign node, string fName){ // sons: (+ - !) (* / %) (true false) (identifier, fun-call, array, lit) 
            parentNode = (dynamic)node;
            var varName = node.AnchorToken.Lexeme;
            // definir si una es una variable local o global
            if(gVar.Contains(varname)){ // variable global
                sb.Append($"     (global.set \n");
                Visit((dynamic) node[0], fName); 
                sb.Append($"    )\n");
            } else {                    // variable local
                sb.Append($"     (local.set \n");
                Visit((dynamic) node[0], fName); 
                sb.Append($"    )\n");
            }
        }

        // LITS
        public void Visit(Int_Literal node, string fName){ 
            var catchVal = node.AnchorToken.Lexeme;
            sb.Append($"     i32.const {catchVal}\n");
        }

        public void Visit(Char_Literal node, string fName){ 
            var catchVal = node.AnchorToken.Lexeme;
            var literal = AsCodePoints(Char.ToString(catchVal));
            sb.Append($"     i32.const {literal}");
        }

        // arrays and string literals are stored in handles (a js array)
        // and are identified in WAT code by their generated labels
        public void Visit(String_Literal node, string fName){ 
            var catchVal = node.AnchorToken.Lexeme;
            IList<int> codes = AsCodePoints(catchVal);
            var t = GenerateLabel();
            t = new(0);
            foreach (int code in codes)
            {
                add(t, code);
            }
            sb.Append($"     i32.const {t}");
        }

        // TRUE && FALSE
        public void Visit(True node, string fName){
            // I HAVE NO KIDS! =)        
              sb.Append("    i32.const 1\n"); 
        }

        public void Visit(False node, string fName){
            // I HAVE NO KIDS! =)
              sb.Append("    i32.const 0\n");
        }

        public void Visit(UnEqual node, string fName){
            VisitChildren(node, fName);
            sb.Append("      i32.ne\n");
        }

        public void Visit(Array node, string fName){ // son: expr-list
            funCallName = "array";
            var t = GenerateLabel();
            t = new(0);
            sb.Append($"     i32.const {t}");
            Visit((dynamic) node[0], fName); 
        }
         // OpAdd
        public void Visit(Neg node, string fName){
            //sb.Append("      i32.const 0\n"); // duda
            VisitChildren( node, fName); 
            sb.Append("      i32.sub\n");
        }

        public void Visit(Plus node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.add\n");
        }

        public void Visit(Not node, string fName){ // !
            VisitChildren( node, fName);
            sb.Append("      i32.eqz\n");
        }

        // OpMul
        public void Visit (Mul node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.mul\n");
        }
        public void Visit (Div node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.div\n");
        }
        public void Visit (Mod node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.rem_s\n");
        }
        
        // OpRel
        public void Visit(Less node, string fName){
            VisitChildren( node , fName);
            sb.Append("      i32.lt_s\n");
        }

        public void Visit(Less_Equal node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.le_s\n");
        }

        public void Visit(More node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.gt_s\n");
        }

        public void Visit(More_Equal node, string fName){
            VisitChildren( node, fName);
            sb.Append("      i32.ge_s\n");
        }

        public void Visit(Equal node, string fName){
            VisitChildren(node, fName);
            sb.Append("      i32.eq\n");
        }

        // OpUnary
        public void Visit (StmtFunCall node, string fName){ //sons:  exprlist
            string funName = node.AnchorToken.Lexeme;
            funCallName = funName;
            parentNode = (dynamic)node;
            //Console.WriteLine(tables.getGlobalFunctions().Contains(funName));
            if(tables.getGlobalFunctions().Contains(funName)){
                // The function exists
                //Console.WriteLine("Hi");
                Visit((dynamic) node[0], fName); //exprlist
            } else {
                throw new SemanticError(
                    "Undeclared function: " + funName, node.AnchorToken);
            }
        }

        
        public void Visit (FunCall node, string fName){ //sons:  exprlist
            string funName = node.AnchorToken.Lexeme;
            funCallName = (dynamic)funName;
            if(tables.getGlobalFunctions().Contains(funName)){
                // The function exists
                //Console.WriteLine("Hi");
                Visit((dynamic) node[0], fName); //exprlist
            } else {
                throw new SemanticError(
                    "Undeclared function: " + funName, node.AnchorToken);
            }
        }
        public void Visit (StmtIncr node, string fName){
            var varName = node.AnchorToken.Lexeme;
            if(tables.getFunctionReference(fName).Contains(varName) || tables.getGlobalVariables().Contains(varName)){ // exists?
                // variable exists, no sons
            }else {  
                throw new SemanticError(
                    "Variable: " + varName + " hasn't been declared in " + fName,
                    node.AnchorToken);
            }
        }
        public void Visit (StmtDecr node, string fName){
            var varName = node.AnchorToken.Lexeme;
            if(tables.getFunctionReference(fName).Contains(varName) || tables.getGlobalVariables().Contains(varName)){ // exists?
                // variable exists, no sons
            }else {  
                throw new SemanticError(
                    "Variable: " + varName + " hasn't been declared in " + fName,
                    node.AnchorToken);
            }
        }
        public void Visit (StmtBreak node, string fName){ //sons: 
        //No tiene hijos
            //Console.WriteLine(inLoop);
            if(inLoop==0){
                throw new SemanticError(
                    "Break not in a while or do while: in " + fName,
                    node.AnchorToken);
            }
        }
           //No tiene hijos
        public void Visit (StmtReturn node, string fName){ //sons:  
           Visit((dynamic) node[0], fName);
        }
        public void Visit (StmtEmpty node, string fName){ //sons:  
           //No tiene hijos
        }

        public void Visit(StmtWhile node, string fName){
            inLoop++;
            Visit((dynamic) node[0], fName);
            Visit((dynamic) node[1], fName);
            inLoop--;
        }

        public void Visit(StmtDoWhile node , string fName){
            inLoop++;
            VisitChildren(node, fName);
            inLoop--;
        }

        public void Visit(StmtIf node, string fName){
            VisitChildren(node, fName);
            
        }

        public void Visit(ElseIfList node, string fName){
            VisitChildren(node, fName);
        }

        public void Visit(Elif node, string fName){
            VisitChildren(node, fName);
        }

        public void Visit(Else node, string fName){
            Visit((dynamic) node[0], fName);
        }

        public void Visit(ExprOr node, string fName){
            VisitChildren( node, fName);
        }

        public void Visit(ExprAnd node, string fName){
            VisitChildren( node, fName);
        }


         //stmt list 

        //

        public void Visit(ExprList node, string fName){ // sons: LITERALS* IDENTIFIER* FUNCALL* ARRAY? EMPTY
           // Received the fName of the function to call
           
           if(funCallName!="array"){
            int sonCtr = 0;
            foreach (var n in node){
                sonCtr++;
            }
            
                int acceptedParams = tables.getGlobalFunctions()[funCallName].getArity();
                
                if (acceptedParams != sonCtr){
                    throw new SemanticError(
                        "The function " + funCallName + " accepts " + acceptedParams + " args, but " + sonCtr + " were found.",
                        parentNode.AnchorToken);
            } else {
                VisitChildren(node, fName); 
            }
           } else {
            VisitChildren(node, fName);
           }

        }

        public void Visit(Condition node, string fName){
            Visit((dynamic) node[0], fName);
        }

        public void Visit(LoopCondition node, string fName){
            Visit((dynamic) node[0], fName);
        }

        
        
        public void VisitChildren(Node node) {
            
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            
        }

        public void VisitChildren(Node node, string fName) {
            
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n, fName));
            }
            
        }
    
    }
}
